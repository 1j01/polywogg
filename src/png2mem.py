# This program splices image data into a running WASM-4 program.
# It uses scanmem to search for sentinel values
# that are generated by png2src.sh and included into the program,
# on either side of the image data.

# For consistency, it uses `w4 png2src` to parse PNGs to image data bytes,
# rather than some Python library.

# TODO: look into using libscanmem, rather than the scanmem CLI

import getpass
if getpass.getuser() != "root":
	# print("This script must be run as root. Use `sudo python3 png2mem.py`")
	# exit(1)
	print("This script should be run as root, using `sudo python3 png2mem.py`")
	print("Continuing on, in case it works anyways...")

import configparser
config = configparser.ConfigParser()
config.read('build/png2src-generated/png2mem.ini')

from subprocess import Popen, PIPE, STDOUT, run

target_pid = run(['pgrep', 'wasm4-linux'], capture_output=True).stdout.splitlines()[0]

p = Popen(['scanmem', '--pid', target_pid], stdout=PIPE, stdin=PIPE, stderr=PIPE)

target_file = "src/png/playerMid.png"

if target_file not in config.sections():
	print("File '%s' not found in ini file. Sections found: %a" % (target_file, config.sections()))
	exit(1)

# Get bytes for start and end sentinels, already formatted for use in scanmem
START_SENTINEL_BYTES_SCANMEM = config.get(target_file, "START_SENTINEL_BYTES_SCANMEM").strip()
END_SENTINEL_BYTES_SCANMEM = config.get(target_file, "END_SENTINEL_BYTES_SCANMEM").strip()

print("START_SENTINEL_BYTES_SCANMEM: ", START_SENTINEL_BYTES_SCANMEM)
print("END_SENTINEL_BYTES_SCANMEM:   ", END_SENTINEL_BYTES_SCANMEM)

scanmem_commands=[
	"option scan_data_type bytearray",
	"reset",
	START_SENTINEL_BYTES_SCANMEM,
	"list",
	"reset",
	END_SENTINEL_BYTES_SCANMEM,
	"list",
]
# p.stdin.writelines([line.encode() for line in scanmem_commands])
# p.stderr.readlines()
stdout_data, stderr_data = p.communicate(input="\n".join(scanmem_commands).encode())
print("stdout:\n    " + "\n    ".join(stdout_data.decode().splitlines()))
print("stderr:\n    " + "\n    ".join(stderr_data.decode().splitlines()))

import re
matches = re.findall(r"\[\s*\d+\]\s([0-9a-fA-F]+),.*,\s*((?:[0-9a-fA-F]{2}\s*)+),\s*\[bytearray\]", stdout_data.decode())
print("matches:", matches)

starts = []
ends = []
for match in matches:
	if match[1].lower().strip() == START_SENTINEL_BYTES_SCANMEM.lower().strip():
		starts.append(match[0])
	elif match[1].lower().strip() == END_SENTINEL_BYTES_SCANMEM.lower().strip():
		ends.append(match[0])
	else:
		print("Warning: matched memory address that doesn't match the search bytes!")
		print("Address:                           "+match[0])
		print("Bytes at address:                  "+match[1])
		print("Expected bytes for start sentinel: "+START_SENTINEL_BYTES_SCANMEM)
		print("Expected bytes for end sentinel:   "+END_SENTINEL_BYTES_SCANMEM)

print("starts:", starts)
print("ends:", ends)

